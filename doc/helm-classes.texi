\input texinfo    @c -*- texinfo -*-
@c %**start of header
@setfilename helm-classes.info
@settitle The Helm Classes Manual
@documentencoding UTF-8
@documentlanguage en
@set txicodequoteundirected
@set txicodequotebacktick
@set MAINTAINERSITE @uref{https://github.com/thierryvolpiatto webpage}
@set MAINTAINER Thierry Volpiatto
@set MAINTAINEREMAIL @email{thierry.volpiatto@gmail.com}
@set MAINTAINERCONTACT @uref{mailto:thierry.volpiatto@gmail.com,contact the maintainer}
@c %**end of header

@dircategory Emacs Add-ons
@direntry
* Helm Classes: (helm-classes). Helm Classes.
@end direntry

@finalout
@titlepage
@title The Helm Classes Manual
@subtitle Release 3.6.2
@author The Helm Classes Developers
@end titlepage

@contents

@ifnottex
@node Top
@top The Helm Classes Manual

@defindex hc
@end ifnottex

@menu
* Overview of Helm Classes::
* class helm-source::
* class helm-source-sync::
* class helm-source-async::
* class helm-source-in-buffer::
* class helm-source-dummy::
* class helm-source-in-file::
* class helm-type-file::
* class helm-type-bookmark::
* class helm-type-buffer::
* class helm-type-function::
* class helm-type-command::
* class helm-type-timers::
* class helm-files-dired-source::
* class helm-source-session-class::
* class helm-mac-spotlight-source::
* class helm-source-basic-bookmarks::
* class helm-source-filtered-bookmarks::
* class helm-bookmark-override-inheritor::
* class helm-bookmark-find-files-class::
* class helm-source-buffers::
* class helm-M-x-class::
* class helm-absolute-time-timers-class::
* class helm-idle-time-timers-class::
* class helm-list-el-package-source::
* class helm-epa::
* class helm-esh-source::
* class helm-eshell-history-source::
* class helm-fd-class::
* class helm-source-ffiles::
* class helm-browse-project-override-inheritor::
* class helm-browse-project-source::
* class helm-file-cache::
* class helm-recentf-source::
* class helm-files-in-current-dir-source::
* class helm-grep-class::
* class helm-grep-ag-class::
* class helm-gid-source::
* class helm-imenu-source::
* class helm-info-source::
* class helm-locate-override-inheritor::
* class helm-locate-source::
* class helm-locate-subdirs-source::
* class helm-moccur-class::
* class helm-semantic-source::
* Main Index::                   An index of Helm-Classes's concepts and features.
* Key Index::                    Key bindings and where they are described.
* Command and Function Index::   Command names and some internal functions.
* Variable Index::               Variables mentioned in the manual.
* Class Index::                  Index of Helm Classes
@end menu

@node Overview of Helm Classes
@chapter Overview of Helm Classes

@image{helm-figures/helm-classes,,,,.png}

@node class helm-source
@chapter class: helm-source

Main interface to define helm sources.

@image{helm-figures/helm-source,,,,.png}

@hcindex helm-source

@hcindex helm-bookmark-override-inheritor

@hcindex helm-type-timers

@hcindex helm-type-command

@hcindex helm-type-function

@hcindex helm-type-buffer

@hcindex helm-type-bookmark

@hcindex helm-type-file

@hcindex helm-source-dummy

@hcindex helm-source-in-buffer

@hcindex helm-source-async

@hcindex helm-source-sync

@table @asis
@item @strong{parents}


@item @strong{children}
@itemize
@item
@ref{class helm-bookmark-override-inheritor}

@item
@ref{class helm-type-timers}

@item
@ref{class helm-type-command}

@item
@ref{class helm-type-function}

@item
@ref{class helm-type-buffer}

@item
@ref{class helm-type-bookmark}

@item
@ref{class helm-type-file}

@item
@ref{class helm-source-dummy}

@item
@ref{class helm-source-in-buffer}

@item
@ref{class helm-source-async}

@item
@ref{class helm-source-sync}
@end itemize
@end table

This class has following slots.

@anchor{init}
@heading init

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{name}
@heading name

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

The name of the source.
A string which is also the heading which appears
above the list of matches from the source. Must be unique.
@end itemize

@anchor{action}
@heading action

@itemize
@item
:type

t

@item
:initform

'identity

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{action-transformer}
@heading action-transformer

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

It's a function or a list of functions called with two
arguments when the action list from the source is
assembled. The first argument is the list of actions, the
second is the current selection.  If it is a list of functions,
it calls each function sequentially.

The function should return a transformed action list.

This can be used to customize the list of actions based on the
currently selected candidate.
@end itemize

@anchor{after-init-hook}
@heading after-init-hook

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A local hook that run at end of initilization of this source.
i.e After the creation of @code{helm-buffer}.

Should be a variable.
Can be also an anonymous function or a list of functions
directly added to slot, this is not recommended though.
@end itemize

@anchor{allow-dups}
@heading allow-dups

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Allow helm collecting duplicates candidates.
@end itemize

@anchor{before-init-hook}
@heading before-init-hook

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A local hook that run at beginning of initilization of this source.
i.e Before the creation of @code{helm-buffer}.

Should be a variable (defined with defvar).
Can be also an anonymous function or a list of functions
directly added to slot, this is not recommended though.
@end itemize

@anchor{candidate-number-limit}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{candidate-transformer}
@heading candidate-transformer

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

It's a function or a list of functions called with one argument
when the completion list from the source is built. The argument
is the list of candidates retrieved from the source. The
function should return a transformed list of candidates which
will be used for the actual completion.  If it is a list of
functions, it calls each function sequentially.

This can be used to transform or remove items from the list of
candidates.

Note that @code{candidates} is run already, so the given transformer
function should also be able to handle candidates with (DISPLAY
. REAL) format.
@end itemize

@anchor{candidates}
@heading candidates

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{cleanup}
@heading cleanup

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Function called with no parameters when @strong{helm} buffer is
closed. It is useful for killing unneeded candidates buffer.

Note that the function is executed BEFORE performing action.
@end itemize

@anchor{coerce}
@heading coerce

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

It's a function called with one argument: the selected candidate.
This function is intended for type convertion. In normal case,
the selected candidate (string) is passed to action
function. If coerce function is specified, it is called just
before action function.

Example: converting string to symbol
  (coerce . intern)
@end itemize

@anchor{delayed}
@heading delayed

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

This slot have no more effect and is just kept for backward compatibility.
Please don't use it.
@end itemize

@anchor{display-to-real}
@heading display-to-real

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Transform the selected candidate when passing it to action.

Function called with one parameter, the selected candidate.

Avoid recomputing all candidates with candidate-transformer
or filtered-candidate-transformer to give a new value to REAL,
instead the selected candidate is transformed only when passing it
to action. This works (and make sense) only with plain string
candidates, it will NOT work when candidate is a cons cell, in this
case the real value of candidate will be used.
Example:

(helm :sources (helm-build-sync-source ``test''
             :candidates '(a b c d e)
             :display-to-real (lambda (c) (concat c ``:modified by d-t-r'')))
  :buffer ``@strong{helm test}'')

Note that this is NOT a transformer,
so the display will not be modified by this function.
@end itemize

@anchor{filter-one-by-one}
@heading filter-one-by-one

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A transformer function that treat candidates one by one.
It is called with one arg the candidate.
It is faster than @code{filtered-candidate-transformer} or
@code{candidate-transformer}, but should be used only in sources
that recompute constantly their candidates, e.g @code{helm-source-find-files}.
Filtering happen early and candidates are treated
one by one instead of re-looping on the whole list.
If used with @code{filtered-candidate-transformer} or @code{candidate-transformer}
these functions should treat the candidates transformed by the
@code{filter-one-by-one} function in consequence.
@end itemize

@anchor{filtered-candidate-transformer}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{follow}
@heading follow

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable @code{helm-follow-mode} for this source only.
With a value of 1 enable, a value of -1 or nil disable the mode.
See @code{helm-follow-mode} for more infos.
@end itemize

@anchor{follow-delay}
@heading follow-delay

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

@code{helm-follow-mode} will execute persistent-action after this delay.
Otherwise value of @code{helm-follow-input-idle-delay} is used if non--nil,
If none of these are found fallback to @code{helm-input-idle-delay}.
@end itemize

@anchor{fuzzy-match}
@heading fuzzy-match

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable fuzzy matching in this source.
This will overwrite settings in MATCH slot, and for
sources built with child class @code{helm-source-in-buffer} the SEARCH slot.
This is an easy way of enabling fuzzy matching, but you can use the MATCH
or SEARCH slots yourself if you want something more elaborated, mixing
different type of match (See @code{helm-source-buffers} class for example).

This attribute is not supported for asynchronous sources
since they perform pattern matching themselves.
@end itemize

@anchor{group}
@heading group

@itemize
@item
:type

t

@item
:initform

helm

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{header-line}
@heading header-line

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Source local @code{header-line-format}.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
It accepts also variable/function name.
@end itemize

@anchor{header-name}
@heading header-name

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A function returning the display string of the header.
Its argument is the name of the source. This attribute is useful to
add an additional information with the source name.
It doesn't modify the name of the source.
@end itemize

@anchor{help-message}
@heading help-message

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{history}
@heading history

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Allow passing history variable to helm from source.
It should be a quoted symbol.
Passing the history variable here have no effect
so add it also in the @code{helm} call with the :history keyword.
The main point of adding the variable here
is to make it available when resuming.
@end itemize

@anchor{keymap}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{marked-with-props}
@heading marked-with-props

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Get candidates with their properties in @code{helm-marked-candidates}.
Allow using the FORCE-DISPLAY-PART of @code{helm-get-selection} in marked
candidates, use t or 'withprop to pass it to @code{helm-get-selection}.
@end itemize

@anchor{match}
@heading match

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{match-on-real}
@heading match-on-real

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Match the real value of candidates when non nil.
@end itemize

@anchor{match-part}
@heading match-part

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Allow matching only one part of candidate.
If source contain match-part attribute, match is computed only
on part of candidate returned by the call of function provided
by this attribute. The function should have one arg, candidate,
and return only a specific part of candidate.
On async sources, as matching is done by the backend, this have
no effect apart for highlighting matches.
@end itemize

@anchor{mode-line}
@heading mode-line

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Source local @code{helm-mode-line-string} (included in
@code{mode-line-format}). It accepts also variable/function name.
@end itemize

@anchor{multiline}
@heading multiline

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Allow multiline candidates.
When non-nil candidates will be separated by @code{helm-candidate-separator}.
You can customize the color of this separator with @code{helm-separator} face.
Value of multiline can be an integer which specify the maximum size of the
multiline string to display, if multiline string is longer than this value
it will be truncated.
@end itemize

@anchor{multimatch}
@heading multimatch

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Use the multi-match algorithm when non-nil.
I.e Allow specifying multiple patterns separated by spaces.
When a pattern is prefixed by ``!'' the negation of this pattern is used,
i.e match anything but this pattern.
It is the standard way of matching in helm and is enabled by default.
It can be used with fuzzy-matching enabled, but as soon helm detect a space,
each pattern will match by regexp and will not be fuzzy.
@end itemize

@anchor{must-match}
@heading must-match

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Same as @code{completing-read} require-match arg.
Possible values are:
@itemize
@item
@code{t} which prevent exiting with an empty helm-buffer i.e. no matches.
@item
@code{confirm} which ask for confirmation i.e. need to press a second
time RET@.
@item
@code{nil} is the default and is doing nothing i.e. returns nil when
pressing RET with an empty helm-buffer.
@item
Any other non nil values e.g. @code{ignore} allow exiting with
minibuffer contents as candidate value (in this case helm-buffer
is empty).
@end itemize
@end itemize

@anchor{nohighlight}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{nomark}
@heading nomark

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Don't allow marking candidates when this attribute is present.
@end itemize

@anchor{pattern-transformer}
@heading pattern-transformer

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

It's a function or a list of functions called with one argument
before computing matches. Its argument is @code{helm-pattern}.
Functions should return transformed @code{helm-pattern}.

It is useful to change interpretation of @code{helm-pattern}.
@end itemize

@anchor{persistent-action}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{persistent-action-if}
@heading persistent-action-if

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Similar from persistent action but it is a function that should
return an object suitable for persistent action when called , i.e. a
function or a cons cell.
Example:

(defun foo-persistent-action (candidate)
  (cond (something
         ;; Don't split helm-window.
         (cons (lambda (_ignore)
                 (do-something candidate))
               'no-split))
        ;; Split helm-window.
        (something-else
         (lambda (_ignore)
           (do-something-else candidate)))))

:persistent-action-if 'foo-persistent-action

Here when hitting @code{C-j} one of the lambda's will be executed
depending on something or something-else condition, splitting or not
splitting as needed.
See @code{helm-find-files-persistent-action-if} definition as another example.
@end itemize

@anchor{persistent-help}
@heading persistent-help

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A string to explain persistent-action of this source. It also
accepts a function or a variable name.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
@end itemize

@anchor{real-to-display}
@heading real-to-display

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Recompute all candidates computed previously with other transformers.

Function called with one parameter, the selected candidate.

The real value of candidates will be shown in display and of course
be used by action.
Example:

(helm :sources (helm-build-sync-source ``test''
             :candidates '((``foo'' . 1) (``bar'' . 2) (``baz''. 3))
             :real-to-display (lambda (c) (format ``%s'' (1+ c))))
  :buffer ``@strong{helm test}'')

Mostly deprecated, kept only for backward compatibility.
@end itemize

@anchor{redisplay}
@heading redisplay

@itemize
@item
:type

t

@item
:initform

'identity

@item
:documentation

A function or a list of functions to apply to current list
of candidates when redisplaying buffer with @code{helm-redisplay-buffer}.
This is only interesting for modifying and redisplaying the whole list
of candidates in async sources.
It uses @code{identity} by default for when async sources are mixed with
normal sources, in this case these normal sources are not modified and
redisplayed as they are.
@end itemize

@anchor{requires-pattern}
@heading requires-pattern

@itemize
@item
:type

t

@item
:initform

0

@item
:documentation

If present matches from the source are shown only if the
pattern is not empty. Optionally, it can have an integer
parameter specifying the required length of input which is
useful in case of sources with lots of candidates.
@end itemize

@anchor{resume}
@heading resume

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Function called with no parameters at end of initialization
when @code{helm-resume} is started.
If this function try to do something against @code{helm-buffer}, (e.g updating,
searching etc@dots{}) probably you should run it in a timer to ensure
@code{helm-buffer} is ready.
@end itemize

@anchor{update}
@heading update

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Function called with no parameters at before ``init'' function
when @code{helm-force-update} is called.
@end itemize

@anchor{volatile}
@heading volatile

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-sync
@chapter class: helm-source-sync

Use this class to make helm sources using a list of candidates.
This list should be given as a normal list, a variable handling a list
or a function returning a list.
Matching is done basically with @code{string-match} against each candidate.

@image{helm-figures/helm-source-sync,,,,.png}

@hcindex helm-source-sync

@hcindex helm-source

@hcindex helm-eshell-history-source

@hcindex helm-esh-source

@hcindex helm-epa

@hcindex helm-source-session-class

@hcindex helm-files-dired-source

@hcindex helm-files-in-current-dir-source

@hcindex helm-recentf-source

@hcindex helm-imenu-source

@hcindex helm-M-x-class

@hcindex helm-idle-time-timers-class

@hcindex helm-absolute-time-timers-class

@hcindex helm-source-ffiles

@hcindex helm-source-buffers

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-eshell-history-source}

@item
@ref{class helm-esh-source}

@item
@ref{class helm-epa}

@item
@ref{class helm-source-session-class}

@item
@ref{class helm-files-dired-source}

@item
@ref{class helm-files-in-current-dir-source}

@item
@ref{class helm-recentf-source}

@item
@ref{class helm-imenu-source}

@item
@ref{class helm-M-x-class}

@item
@ref{class helm-idle-time-timers-class}

@item
@ref{class helm-absolute-time-timers-class}

@item
@ref{class helm-source-ffiles}

@item
@ref{class helm-source-buffers}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{candidates (1)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'(``ERROR: You must specify the @code{candidates} slot, either with a list or a function'')

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{match-dynamic}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-strict}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{Specialized Methods (1)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-async
@chapter class: helm-source-async

Use this class to define a helm source calling an external process.
The external process is called typically in a @code{start-process} call to be
asynchronous.

Note that using multiples asynchronous sources is not fully working,
expect weird behavior if you try this.

The :candidates slot is not allowed even if described because this class
inherit from @code{helm-source}.

@image{helm-figures/helm-source-async,,,,.png}

@hcindex helm-source-async

@hcindex helm-source

@hcindex helm-gid-source

@hcindex helm-fd-class

@hcindex helm-mac-spotlight-source

@hcindex helm-locate-source

@hcindex helm-grep-ag-class

@hcindex helm-grep-class

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-gid-source}

@item
@ref{class helm-fd-class}

@item
@ref{class helm-mac-spotlight-source}

@item
@ref{class helm-locate-source}

@item
@ref{class helm-grep-ag-class}

@item
@ref{class helm-grep-class}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{candidates-process}
@heading candidates-process

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

This attribute is used to define a process as candidate.
The function called with no arguments must return a process
i.e. @code{processp}, it use typically @code{start-process} or @code{make-process},
see (info ``(elisp) Asynchronous Processes'').

NOTE:
When building the source at runtime you can give directly a process
as value, otherwise wrap the process call into a function.
The process buffer should be nil, otherwise, if you use
@code{helm-buffer} give to the process a sentinel.
@end itemize

@anchor{multimatch (1)}
@heading multimatch

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Use the multi-match algorithm when non-nil.
I.e Allow specifying multiple patterns separated by spaces.
When a pattern is prefixed by ``!'' the negation of this pattern is used,
i.e match anything but this pattern.
It is the standard way of matching in helm and is enabled by default.
It can be used with fuzzy-matching enabled, but as soon helm detect a space,
each pattern will match by regexp and will not be fuzzy.
@end itemize

@anchor{Specialized Methods (2)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-async))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-in-buffer
@chapter class: helm-source-in-buffer

Use this source to make helm sources storing candidates inside a buffer.

The buffer storing candidates is generated by @code{helm-candidate-buffer} function
and all search are done in this buffer, results are transfered to the @code{helm-buffer}
when done.
Contrarily to @code{helm-source-sync} candidates are matched using a function
like @code{re-search-forward} (see below documentation of @code{:search} slot) which makes
the search much faster than matching candidates one by one.
If you want to add search functions to your sources, don't use @code{:match} which
will raise an error, but @code{:search}.
See @code{helm-candidates-in-buffer} for more infos.

@image{helm-figures/helm-source-in-buffer,,,,.png}

@hcindex helm-source-in-buffer

@hcindex helm-source

@hcindex helm-list-el-package-source

@hcindex helm-file-cache

@hcindex helm-source-filtered-bookmarks

@hcindex helm-source-basic-bookmarks

@hcindex helm-semantic-source

@hcindex helm-info-source

@hcindex helm-browse-project-source

@hcindex helm-moccur-class

@hcindex helm-locate-subdirs-source

@hcindex helm-source-in-file

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-list-el-package-source}

@item
@ref{class helm-file-cache}

@item
@ref{class helm-source-filtered-bookmarks}

@item
@ref{class helm-source-basic-bookmarks}

@item
@ref{class helm-semantic-source}

@item
@ref{class helm-info-source}

@item
@ref{class helm-browse-project-source}

@item
@ref{class helm-moccur-class}

@item
@ref{class helm-locate-subdirs-source}

@item
@ref{class helm-source-in-file}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (1)}
@heading init

@itemize
@item
:type

t

@item
:initform

'helm-default-init-source-in-buffer-function

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (2)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-candidates-in-buffer

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{data}
@heading data

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A string, a list or a buffer that will be used to feed the @code{helm-candidates-buffer}.
This data will be passed in a function added to the init slot and
the buffer will be build with @code{helm-init-candidates-in-buffer} or directly
with @code{helm-candidates-buffer} if data is a buffer.
This is an easy and fast method to build a @code{candidates-in-buffer} source.
@end itemize

@anchor{get-line}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring-no-properties

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{match (1)}
@heading match

@itemize
@item
:type

t

@item
:initform

'(identity)

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{migemo (1)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{search}
@heading search

@itemize
@item
:type

t

@item
:initform

'(helm-candidates-in-buffer-search-default-fn)

@item
:documentation

List of functions like @code{re-search-forward} or @code{search-forward}.
Buffer search function used by @code{helm-candidates-in-buffer}.
By default, @code{helm-candidates-in-buffer} uses @code{re-search-forward}.
The function should take one arg PATTERN@.
If your search function needs to handle negation like multimatch,
this function should returns in such case a cons cell of two integers defining
the beg and end positions to match in the line previously matched by
@code{re-search-forward} or similar, and move point to next line
(See how the @code{helm-mm-3-search-base} and @code{helm-fuzzy-search} functions are working).

NOTE: FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{search-strict}
@heading search-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a search function within a source and
helm-multi-match is enabled, the result of all searching
functions will be concatened, which in some cases is not what
is wanted. When using @code{search-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using a nil value for
      :MULTIMATCH slot.
@end itemize

@anchor{volatile (1)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (3)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-dummy
@chapter class: helm-source-dummy

@image{helm-figures/helm-source-dummy,,,,.png}

@hcindex helm-source-dummy

@hcindex helm-source

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{accept-empty}
@heading accept-empty

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Allow exiting with an empty string.
You should keep the default value.
@end itemize

@anchor{candidates (3)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'(``dummy'')

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{filtered-candidate-transformer (1)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

(lambda (_candidates _source) (list helm-pattern))

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{match (2)}
@heading match

@itemize
@item
:type

t

@item
:initform

'identity

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{multimatch (2)}
@heading multimatch

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Use the multi-match algorithm when non-nil.
I.e Allow specifying multiple patterns separated by spaces.
When a pattern is prefixed by ``!'' the negation of this pattern is used,
i.e match anything but this pattern.
It is the standard way of matching in helm and is enabled by default.
It can be used with fuzzy-matching enabled, but as soon helm detect a space,
each pattern will match by regexp and will not be fuzzy.
@end itemize

@anchor{volatile (2)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (4)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-dummy))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-in-file
@chapter class: helm-source-in-file

The contents of the FILE will be used as candidates in buffer.

@image{helm-figures/helm-source-in-file,,,,.png}

@hcindex helm-source-in-file

@hcindex helm-source-in-buffer

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (2)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (let ((file (helm-get-attr 'candidates-file)) (count 1)) (with-current-buffer (helm-candidate-buffer 'global) (insert-file-contents file) (goto-char (point-min)) (while (not (eobp)) (add-text-properties (point-at-bol) (point-at-eol) `(helm-linum ,count)) (cl-incf count) (forward-line 1)))))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates-file}
@heading candidates-file

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A filename.
Each line number of FILE is accessible with helm-linum property
from candidate display part.
@end itemize

@anchor{get-line (1)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

#'buffer-substring

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{Specialized Methods (5)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-type-file
@chapter class: helm-type-file

A class to define helm type file.

@image{helm-figures/helm-type-file,,,,.png}

@hcindex helm-type-file

@hcindex helm-source

@hcindex helm-mac-spotlight-source

@hcindex helm-files-dired-source

@hcindex helm-files-in-current-dir-source

@hcindex helm-recentf-source

@hcindex helm-file-cache

@hcindex helm-browse-project-override-inheritor

@hcindex helm-locate-override-inheritor

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-mac-spotlight-source}

@item
@ref{class helm-files-dired-source}

@item
@ref{class helm-files-in-current-dir-source}

@item
@ref{class helm-recentf-source}

@item
@ref{class helm-file-cache}

@item
@ref{class helm-browse-project-override-inheritor}

@item
@ref{class helm-locate-override-inheritor}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (6)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-file))
:before ((source helm-type-file))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-type-bookmark
@chapter class: helm-type-bookmark

A class to define type bookmarks.

@image{helm-figures/helm-type-bookmark,,,,.png}

@hcindex helm-type-bookmark

@hcindex helm-source

@hcindex helm-source-filtered-bookmarks

@hcindex helm-source-basic-bookmarks

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-source-filtered-bookmarks}

@item
@ref{class helm-source-basic-bookmarks}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (7)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-bookmark))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-bookmark))
:before ((source helm-type-bookmark))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-type-buffer
@chapter class: helm-type-buffer

A class to define type buffer.

@image{helm-figures/helm-type-buffer,,,,.png}

@hcindex helm-type-buffer

@hcindex helm-source

@hcindex helm-source-buffers

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-source-buffers}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (8)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-buffer))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-buffer))
:before ((source helm-type-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-type-function
@chapter class: helm-type-function

A class to define helm type function.

@image{helm-figures/helm-type-function,,,,.png}

@hcindex helm-type-function

@hcindex helm-source

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (9)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-function))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-function))
:before ((source helm-type-function))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-type-command
@chapter class: helm-type-command

A class to define helm type command.

@image{helm-figures/helm-type-command,,,,.png}

@hcindex helm-type-command

@hcindex helm-source

@hcindex helm-M-x-class

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-M-x-class}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (10)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-command))
:before ((source helm-type-command))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-type-timers
@chapter class: helm-type-timers

A class to define helm type timers.

@image{helm-figures/helm-type-timers,,,,.png}

@hcindex helm-type-timers

@hcindex helm-source

@hcindex helm-idle-time-timers-class

@hcindex helm-absolute-time-timers-class

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-idle-time-timers-class}

@item
@ref{class helm-absolute-time-timers-class}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (11)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-timers))
:before ((source helm-type-timers))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-files-dired-source
@chapter class: helm-files-dired-source

@image{helm-figures/helm-files-dired-source,,,,.png}

@hcindex helm-files-dired-source

@hcindex helm-source-sync

@hcindex helm-type-file

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}

@item
@ref{class helm-type-file}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{candidates (4)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

#'helm-files-in-all-dired-candidates

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{match-dynamic (1)}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-strict (1)}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo (2)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{Specialized Methods (12)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))
((_source helm-type-file))
:before ((source helm-type-file))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-session-class
@chapter class: helm-source-session-class

@image{helm-figures/helm-source-session-class,,,,.png}

@hcindex helm-source-session-class

@hcindex helm-source-sync

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{action (1)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-type-file-actions

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{candidates (5)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

(lambda nil (cl-delete-if-not (lambda (f) (or (string-match helm-tramp-file-name-regexp f) (file-exists-p f))) (mapcar 'car session-file-alist)))

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{help-message (1)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

helm-generic-file-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (1)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-generic-files-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{Specialized Methods (13)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-mac-spotlight-source
@chapter class: helm-mac-spotlight-source

@image{helm-figures/helm-mac-spotlight-source,,,,.png}

@hcindex helm-mac-spotlight-source

@hcindex helm-source-async

@hcindex helm-type-file

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-async}

@item
@ref{class helm-type-file}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{candidates-process (1)}
@heading candidates-process

@itemize
@item
:type

t

@item
:initform

(lambda nil (start-process ``mdfind-process'' nil ``mdfind'' helm-pattern))

@item
:documentation

This attribute is used to define a process as candidate.
The function called with no arguments must return a process
i.e. @code{processp}, it use typically @code{start-process} or @code{make-process},
see (info ``(elisp) Asynchronous Processes'').

NOTE:
When building the source at runtime you can give directly a process
as value, otherwise wrap the process call into a function.
The process buffer should be nil, otherwise, if you use
@code{helm-buffer} give to the process a sentinel.
@end itemize

@anchor{multimatch (3)}
@heading multimatch

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Use the multi-match algorithm when non-nil.
I.e Allow specifying multiple patterns separated by spaces.
When a pattern is prefixed by ``!'' the negation of this pattern is used,
i.e match anything but this pattern.
It is the standard way of matching in helm and is enabled by default.
It can be used with fuzzy-matching enabled, but as soon helm detect a space,
each pattern will match by regexp and will not be fuzzy.
@end itemize

@anchor{requires-pattern (1)}
@heading requires-pattern

@itemize
@item
:type

t

@item
:initform

3

@item
:documentation

If present matches from the source are shown only if the
pattern is not empty. Optionally, it can have an integer
parameter specifying the required length of input which is
useful in case of sources with lots of candidates.
@end itemize

@anchor{Specialized Methods (14)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-async))
((_source helm-type-file))
:before ((source helm-type-file))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-basic-bookmarks
@chapter class: helm-source-basic-bookmarks

@image{helm-figures/helm-source-basic-bookmarks,,,,.png}

@hcindex helm-source-basic-bookmarks

@hcindex helm-source-in-buffer

@hcindex helm-type-bookmark

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}

@item
@ref{class helm-type-bookmark}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (3)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (bookmark-maybe-load-default-file) (helm-init-candidates-in-buffer 'global (bookmark-all-names)))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (6)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-candidates-in-buffer

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{data (1)}
@heading data

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A string, a list or a buffer that will be used to feed the @code{helm-candidates-buffer}.
This data will be passed in a function added to the init slot and
the buffer will be build with @code{helm-init-candidates-in-buffer} or directly
with @code{helm-candidates-buffer} if data is a buffer.
This is an easy and fast method to build a @code{candidates-in-buffer} source.
@end itemize

@anchor{filtered-candidate-transformer (2)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

'helm-bookmark-transformer

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{get-line (2)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring-no-properties

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{match (3)}
@heading match

@itemize
@item
:type

t

@item
:initform

'(identity)

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{migemo (3)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{search (1)}
@heading search

@itemize
@item
:type

t

@item
:initform

'(helm-candidates-in-buffer-search-default-fn)

@item
:documentation

List of functions like @code{re-search-forward} or @code{search-forward}.
Buffer search function used by @code{helm-candidates-in-buffer}.
By default, @code{helm-candidates-in-buffer} uses @code{re-search-forward}.
The function should take one arg PATTERN@.
If your search function needs to handle negation like multimatch,
this function should returns in such case a cons cell of two integers defining
the beg and end positions to match in the line previously matched by
@code{re-search-forward} or similar, and move point to next line
(See how the @code{helm-mm-3-search-base} and @code{helm-fuzzy-search} functions are working).

NOTE: FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{search-strict (1)}
@heading search-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a search function within a source and
helm-multi-match is enabled, the result of all searching
functions will be concatened, which in some cases is not what
is wanted. When using @code{search-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using a nil value for
      :MULTIMATCH slot.
@end itemize

@anchor{volatile (3)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (15)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-bookmark))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))
((_source helm-type-bookmark))
:before ((source helm-type-bookmark))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-filtered-bookmarks
@chapter class: helm-source-filtered-bookmarks

@image{helm-figures/helm-source-filtered-bookmarks,,,,.png}

@hcindex helm-source-filtered-bookmarks

@hcindex helm-source-in-buffer

@hcindex helm-type-bookmark

@hcindex helm-bookmark-find-files-class

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}

@item
@ref{class helm-type-bookmark}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-bookmark-find-files-class}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (4)}
@heading init

@itemize
@item
:type

t

@item
:initform

'helm-default-init-source-in-buffer-function

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (7)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-candidates-in-buffer

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{data (2)}
@heading data

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A string, a list or a buffer that will be used to feed the @code{helm-candidates-buffer}.
This data will be passed in a function added to the init slot and
the buffer will be build with @code{helm-init-candidates-in-buffer} or directly
with @code{helm-candidates-buffer} if data is a buffer.
This is an easy and fast method to build a @code{candidates-in-buffer} source.
@end itemize

@anchor{filtered-candidate-transformer (3)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

'(helm-adaptive-sort helm-highlight-bookmark)

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{get-line (3)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring-no-properties

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{match (4)}
@heading match

@itemize
@item
:type

t

@item
:initform

'(identity)

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{migemo (4)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{search (2)}
@heading search

@itemize
@item
:type

t

@item
:initform

'(helm-candidates-in-buffer-search-default-fn)

@item
:documentation

List of functions like @code{re-search-forward} or @code{search-forward}.
Buffer search function used by @code{helm-candidates-in-buffer}.
By default, @code{helm-candidates-in-buffer} uses @code{re-search-forward}.
The function should take one arg PATTERN@.
If your search function needs to handle negation like multimatch,
this function should returns in such case a cons cell of two integers defining
the beg and end positions to match in the line previously matched by
@code{re-search-forward} or similar, and move point to next line
(See how the @code{helm-mm-3-search-base} and @code{helm-fuzzy-search} functions are working).

NOTE: FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{search-strict (2)}
@heading search-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a search function within a source and
helm-multi-match is enabled, the result of all searching
functions will be concatened, which in some cases is not what
is wanted. When using @code{search-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using a nil value for
      :MULTIMATCH slot.
@end itemize

@anchor{volatile (4)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (16)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-bookmark))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))
((_source helm-type-bookmark))
:before ((source helm-type-bookmark))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-bookmark-override-inheritor
@chapter class: helm-bookmark-override-inheritor

@image{helm-figures/helm-bookmark-override-inheritor,,,,.png}

@hcindex helm-bookmark-override-inheritor

@hcindex helm-source

@hcindex helm-bookmark-find-files-class

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-bookmark-find-files-class}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (17)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-bookmark-override-inheritor))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-bookmark-find-files-class
@chapter class: helm-bookmark-find-files-class

@image{helm-figures/helm-bookmark-find-files-class,,,,.png}

@hcindex helm-bookmark-find-files-class

@hcindex helm-source-filtered-bookmarks

@hcindex helm-bookmark-override-inheritor

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-filtered-bookmarks}

@item
@ref{class helm-bookmark-override-inheritor}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (5)}
@heading init

@itemize
@item
:type

t

@item
:initform

'helm-default-init-source-in-buffer-function

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (8)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-candidates-in-buffer

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{data (3)}
@heading data

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A string, a list or a buffer that will be used to feed the @code{helm-candidates-buffer}.
This data will be passed in a function added to the init slot and
the buffer will be build with @code{helm-init-candidates-in-buffer} or directly
with @code{helm-candidates-buffer} if data is a buffer.
This is an easy and fast method to build a @code{candidates-in-buffer} source.
@end itemize

@anchor{filtered-candidate-transformer (4)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

'(helm-adaptive-sort helm-highlight-bookmark)

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{get-line (4)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring-no-properties

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{match (5)}
@heading match

@itemize
@item
:type

t

@item
:initform

'(identity)

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{migemo (5)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{search (3)}
@heading search

@itemize
@item
:type

t

@item
:initform

'(helm-candidates-in-buffer-search-default-fn)

@item
:documentation

List of functions like @code{re-search-forward} or @code{search-forward}.
Buffer search function used by @code{helm-candidates-in-buffer}.
By default, @code{helm-candidates-in-buffer} uses @code{re-search-forward}.
The function should take one arg PATTERN@.
If your search function needs to handle negation like multimatch,
this function should returns in such case a cons cell of two integers defining
the beg and end positions to match in the line previously matched by
@code{re-search-forward} or similar, and move point to next line
(See how the @code{helm-mm-3-search-base} and @code{helm-fuzzy-search} functions are working).

NOTE: FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{search-strict (3)}
@heading search-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a search function within a source and
helm-multi-match is enabled, the result of all searching
functions will be concatened, which in some cases is not what
is wanted. When using @code{search-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using a nil value for
      :MULTIMATCH slot.
@end itemize

@anchor{volatile (5)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (18)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-bookmark))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))
((_source helm-type-bookmark))
:before ((source helm-type-bookmark))
((source helm-bookmark-override-inheritor))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-buffers
@chapter class: helm-source-buffers

@image{helm-figures/helm-source-buffers,,,,.png}

@hcindex helm-source-buffers

@hcindex helm-source-sync

@hcindex helm-type-buffer

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}

@item
@ref{class helm-type-buffer}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (6)}
@heading init

@itemize
@item
:type

t

@item
:initform

'helm-buffers-list--init

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{buffer-list}
@heading buffer-list

@itemize
@item
:type

t

@item
:initform

#'helm-buffer-list

@item
:documentation

A function with no arguments to create buffer list.
@end itemize

@anchor{candidates (9)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'(``ERROR: You must specify the @code{candidates} slot, either with a list or a function'')

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{help-message (2)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-buffer-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (2)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-buffer-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{match (6)}
@heading match

@itemize
@item
:type

t

@item
:initform

'helm-buffers-match-function

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{match-dynamic (2)}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-strict (2)}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo (6)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

'nomultimatch

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{multimatch (4)}
@heading multimatch

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Use the multi-match algorithm when non-nil.
I.e Allow specifying multiple patterns separated by spaces.
When a pattern is prefixed by ``!'' the negation of this pattern is used,
i.e match anything but this pattern.
It is the standard way of matching in helm and is enabled by default.
It can be used with fuzzy-matching enabled, but as soon helm detect a space,
each pattern will match by regexp and will not be fuzzy.
@end itemize

@anchor{nohighlight (1)}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{persistent-action (1)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'helm-buffers-list-persistent-action

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{resume (1)}
@heading resume

@itemize
@item
:type

t

@item
:initform

(lambda nil (setq helm-buffers-in-project-p nil))

@item
:documentation

Function called with no parameters at end of initialization
when @code{helm-resume} is started.
If this function try to do something against @code{helm-buffer}, (e.g updating,
searching etc@dots{}) probably you should run it in a timer to ensure
@code{helm-buffer} is ready.
@end itemize

@anchor{volatile (6)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (19)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-buffer))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))
((_source helm-type-buffer))
:before ((source helm-type-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-M-x-class
@chapter class: helm-M-x-class

@image{helm-figures/helm-M-x-class,,,,.png}

@hcindex helm-M-x-class

@hcindex helm-source-sync

@hcindex helm-type-command

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}

@item
@ref{class helm-type-command}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{candidates (10)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'(``ERROR: You must specify the @code{candidates} slot, either with a list or a function'')

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{filtered-candidate-transformer (5)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

'helm-M-x-transformer-no-sort

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{help-message (3)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-M-x-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (3)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-M-x-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{match-dynamic (3)}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-strict (3)}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo (7)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{must-match (1)}
@heading must-match

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Same as @code{completing-read} require-match arg.
Possible values are:
@itemize
@item
@code{t} which prevent exiting with an empty helm-buffer i.e. no matches.
@item
@code{confirm} which ask for confirmation i.e. need to press a second
time RET@.
@item
@code{nil} is the default and is doing nothing i.e. returns nil when
pressing RET with an empty helm-buffer.
@item
Any other non nil values e.g. @code{ignore} allow exiting with
minibuffer contents as candidate value (in this case helm-buffer
is empty).
@end itemize
@end itemize

@anchor{nomark (1)}
@heading nomark

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Don't allow marking candidates when this attribute is present.
@end itemize

@anchor{persistent-help (1)}
@heading persistent-help

@itemize
@item
:type

t

@item
:initform

``Describe this command''

@item
:documentation

A string to explain persistent-action of this source. It also
accepts a function or a variable name.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
@end itemize

@anchor{Specialized Methods (20)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))
((_source helm-type-command))
:before ((source helm-type-command))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-absolute-time-timers-class
@chapter class: helm-absolute-time-timers-class

@image{helm-figures/helm-absolute-time-timers-class,,,,.png}

@hcindex helm-absolute-time-timers-class

@hcindex helm-source-sync

@hcindex helm-type-timers

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}

@item
@ref{class helm-type-timers}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{allow-dups (1)}
@heading allow-dups

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Allow helm collecting duplicates candidates.
@end itemize

@anchor{candidate-transformer (1)}
@heading candidate-transformer

@itemize
@item
:type

t

@item
:initform

(lambda (candidates) (cl-loop for timer in candidates collect (cons (helm-elisp--format-timer timer) timer)))

@item
:documentation

It's a function or a list of functions called with one argument
when the completion list from the source is built. The argument
is the list of candidates retrieved from the source. The
function should return a transformed list of candidates which
will be used for the actual completion.  If it is a list of
functions, it calls each function sequentially.

This can be used to transform or remove items from the list of
candidates.

Note that @code{candidates} is run already, so the given transformer
function should also be able to handle candidates with (DISPLAY
. REAL) format.
@end itemize

@anchor{candidates (11)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

timer-list

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{match-dynamic (4)}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-strict (4)}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo (8)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{Specialized Methods (21)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))
((_source helm-type-timers))
:before ((source helm-type-timers))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-idle-time-timers-class
@chapter class: helm-idle-time-timers-class

@image{helm-figures/helm-idle-time-timers-class,,,,.png}

@hcindex helm-idle-time-timers-class

@hcindex helm-source-sync

@hcindex helm-type-timers

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}

@item
@ref{class helm-type-timers}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{allow-dups (2)}
@heading allow-dups

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Allow helm collecting duplicates candidates.
@end itemize

@anchor{candidate-transformer (2)}
@heading candidate-transformer

@itemize
@item
:type

t

@item
:initform

(lambda (candidates) (cl-loop for timer in candidates collect (cons (helm-elisp--format-timer timer) timer)))

@item
:documentation

It's a function or a list of functions called with one argument
when the completion list from the source is built. The argument
is the list of candidates retrieved from the source. The
function should return a transformed list of candidates which
will be used for the actual completion.  If it is a list of
functions, it calls each function sequentially.

This can be used to transform or remove items from the list of
candidates.

Note that @code{candidates} is run already, so the given transformer
function should also be able to handle candidates with (DISPLAY
. REAL) format.
@end itemize

@anchor{candidates (12)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

timer-idle-list

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{match-dynamic (5)}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-strict (5)}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo (9)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{Specialized Methods (22)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))
((_source helm-type-timers))
:before ((source helm-type-timers))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-list-el-package-source
@chapter class: helm-list-el-package-source

@image{helm-figures/helm-list-el-package-source,,,,.png}

@hcindex helm-list-el-package-source

@hcindex helm-source-in-buffer

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (7)}
@heading init

@itemize
@item
:type

t

@item
:initform

'helm-el-package--init

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{action (2)}
@heading action

@itemize
@item
:type

t

@item
:initform

'((``Describe package'' . helm-el-package-describe) (``Visit homepage'' . helm-el-package-visit-homepage))

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{action-transformer (1)}
@heading action-transformer

@itemize
@item
:type

t

@item
:initform

'helm-el-package--action-transformer

@item
:documentation

It's a function or a list of functions called with two
arguments when the action list from the source is
assembled. The first argument is the list of actions, the
second is the current selection.  If it is a list of functions,
it calls each function sequentially.

The function should return a transformed action list.

This can be used to customize the list of actions based on the
currently selected candidate.
@end itemize

@anchor{candidate-number-limit (1)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

9999

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{filtered-candidate-transformer (6)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

'helm-el-package--transformer

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{get-line (5)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{group (1)}
@heading group

@itemize
@item
:type

t

@item
:initform

'helm-el-package

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{help-message (4)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-el-package-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (4)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-el-package-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{update (1)}
@heading update

@itemize
@item
:type

t

@item
:initform

'helm-el-package--update

@item
:documentation

Function called with no parameters at before ``init'' function
when @code{helm-force-update} is called.
@end itemize

@anchor{Specialized Methods (23)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-epa
@chapter class: helm-epa

Allow building helm sources for GPG keys.

@image{helm-figures/helm-epa,,,,.png}

@hcindex helm-epa

@hcindex helm-source-sync

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (8)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (require 'epg) (require 'epa))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (13)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-epa-get-key-list

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{keymap (5)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-comp-read-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{mode-line (1)}
@heading mode-line

@itemize
@item
:type

t

@item
:initform

helm-comp-read-mode-line

@item
:documentation

Source local @code{helm-mode-line-string} (included in
@code{mode-line-format}). It accepts also variable/function name.
@end itemize

@anchor{Specialized Methods (24)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-esh-source
@chapter class: helm-esh-source

Helm class to define source for Eshell completion.

@image{helm-figures/helm-esh-source,,,,.png}

@hcindex helm-esh-source

@hcindex helm-source-sync

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (9)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (setq pcomplete-current-completions nil pcomplete-last-completion-raw nil) (remove-hook 'minibuffer-setup-hook 'eshell-mode))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{action (3)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-ec-insert

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{candidates (14)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-esh-get-candidates

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{filtered-candidate-transformer (7)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

#'helm-esh-transformer

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{nohighlight (2)}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{persistent-action (2)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'ignore

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{Specialized Methods (25)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-eshell-history-source
@chapter class: helm-eshell-history-source

Helm class to define source for Eshell history.

@image{helm-figures/helm-eshell-history-source,,,,.png}

@hcindex helm-eshell-history-source

@hcindex helm-source-sync

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (10)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (remove-hook 'minibuffer-setup-hook 'eshell-mode))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{action (4)}
@heading action

@itemize
@item
:type

t

@item
:initform

(lambda (candidate) (eshell-kill-input) (insert candidate))

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{candidate-number-limit (2)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

9999

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{candidates (15)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

(lambda nil (with-helm-current-buffer (cl-loop for c from 0 to (ring-length eshell-history-ring) for elm = (eshell-get-history c) unless (and (member elm lst) eshell-hist-ignoredups) collect elm into lst finally return lst)))

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{keymap (6)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-eshell-history-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{multiline (1)}
@heading multiline

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Allow multiline candidates.
When non-nil candidates will be separated by @code{helm-candidate-separator}.
You can customize the color of this separator with @code{helm-separator} face.
Value of multiline can be an integer which specify the maximum size of the
multiline string to display, if multiline string is longer than this value
it will be truncated.
@end itemize

@anchor{nomark (2)}
@heading nomark

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Don't allow marking candidates when this attribute is present.
@end itemize

@anchor{Specialized Methods (26)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-fd-class
@chapter class: helm-fd-class

@image{helm-figures/helm-fd-class,,,,.png}

@hcindex helm-fd-class

@hcindex helm-source-async

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-async}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{action (5)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-type-file-actions

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{candidate-number-limit (3)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

20000

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{candidates-process (2)}
@heading candidates-process

@itemize
@item
:type

t

@item
:initform

'helm-fd-process

@item
:documentation

This attribute is used to define a process as candidate.
The function called with no arguments must return a process
i.e. @code{processp}, it use typically @code{start-process} or @code{make-process},
see (info ``(elisp) Asynchronous Processes'').

NOTE:
When building the source at runtime you can give directly a process
as value, otherwise wrap the process call into a function.
The process buffer should be nil, otherwise, if you use
@code{helm-buffer} give to the process a sentinel.
@end itemize

@anchor{filtered-candidate-transformer (8)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

'helm-fd-fct

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{help-message (5)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-fd-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (7)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-fd-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{nohighlight (3)}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{requires-pattern (2)}
@heading requires-pattern

@itemize
@item
:type

t

@item
:initform

2

@item
:documentation

If present matches from the source are shown only if the
pattern is not empty. Optionally, it can have an integer
parameter specifying the required length of input which is
useful in case of sources with lots of candidates.
@end itemize

@anchor{Specialized Methods (27)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-async))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-source-ffiles
@chapter class: helm-source-ffiles

@image{helm-figures/helm-source-ffiles,,,,.png}

@hcindex helm-source-ffiles

@hcindex helm-source-sync

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (11)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (setq helm-ff-auto-update-flag helm-ff-auto-update-initial-value) (setq helm-ff--auto-update-state helm-ff-auto-update-flag) (helm-set-local-variable 'bookmark-make-record-function #'helm-ff-make-bookmark-record) (require 'helm-external))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{action (6)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-find-files-actions

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{action-transformer (2)}
@heading action-transformer

@itemize
@item
:type

t

@item
:initform

'helm-find-files-action-transformer

@item
:documentation

It's a function or a list of functions called with two
arguments when the action list from the source is
assembled. The first argument is the list of actions, the
second is the current selection.  If it is a list of functions,
it calls each function sequentially.

The function should return a transformed action list.

This can be used to customize the list of actions based on the
currently selected candidate.
@end itemize

@anchor{after-init-hook (1)}
@heading after-init-hook

@itemize
@item
:type

t

@item
:initform

'helm-find-files-after-init-hook

@item
:documentation

A local hook that run at end of initilization of this source.
i.e After the creation of @code{helm-buffer}.

Should be a variable.
Can be also an anonymous function or a list of functions
directly added to slot, this is not recommended though.
@end itemize

@anchor{before-init-hook (1)}
@heading before-init-hook

@itemize
@item
:type

t

@item
:initform

'helm-find-files-before-init-hook

@item
:documentation

A local hook that run at beginning of initilization of this source.
i.e Before the creation of @code{helm-buffer}.

Should be a variable (defined with defvar).
Can be also an anonymous function or a list of functions
directly added to slot, this is not recommended though.
@end itemize

@anchor{candidate-number-limit (4)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

'helm-ff-candidate-number-limit

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{candidates (16)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-find-files-get-candidates

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{cleanup (1)}
@heading cleanup

@itemize
@item
:type

t

@item
:initform

'helm-find-files-cleanup

@item
:documentation

Function called with no parameters when @strong{helm} buffer is
closed. It is useful for killing unneeded candidates buffer.

Note that the function is executed BEFORE performing action.
@end itemize

@anchor{filtered-candidate-transformer (9)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

'(helm-ff-fct helm-ff-directories-only helm-ff-files-only helm-ff-sort-candidates)

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{group (2)}
@heading group

@itemize
@item
:type

t

@item
:initform

'helm-files

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{header-name (1)}
@heading header-name

@itemize
@item
:type

t

@item
:initform

(lambda (name) (concat name (substitute-command-keys helm-find-files-doc-header)))

@item
:documentation

A function returning the display string of the header.
Its argument is the name of the source. This attribute is useful to
add an additional information with the source name.
It doesn't modify the name of the source.
@end itemize

@anchor{help-message (6)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-ff-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (8)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-find-files-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{match-on-real (1)}
@heading match-on-real

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Match the real value of candidates when non nil.
@end itemize

@anchor{migemo (10)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{mode-line (2)}
@heading mode-line

@itemize
@item
:type

t

@item
:initform

(list ``File(s)'' helm-mode-line-string)

@item
:documentation

Source local @code{helm-mode-line-string} (included in
@code{mode-line-format}). It accepts also variable/function name.
@end itemize

@anchor{nohighlight (4)}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{persistent-action-if (1)}
@heading persistent-action-if

@itemize
@item
:type

t

@item
:initform

'helm-find-files-persistent-action-if

@item
:documentation

Similar from persistent action but it is a function that should
return an object suitable for persistent action when called , i.e. a
function or a cons cell.
Example:

(defun foo-persistent-action (candidate)
  (cond (something
         ;; Don't split helm-window.
         (cons (lambda (_ignore)
                 (do-something candidate))
               'no-split))
        ;; Split helm-window.
        (something-else
         (lambda (_ignore)
           (do-something-else candidate)))))

:persistent-action-if 'foo-persistent-action

Here when hitting @code{C-j} one of the lambda's will be executed
depending on something or something-else condition, splitting or not
splitting as needed.
See @code{helm-find-files-persistent-action-if} definition as another example.
@end itemize

@anchor{persistent-help (2)}
@heading persistent-help

@itemize
@item
:type

t

@item
:initform

``Hit1 Expand Candidate, Hit2 or (C-u) Find file''

@item
:documentation

A string to explain persistent-action of this source. It also
accepts a function or a variable name.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
@end itemize

@anchor{update (2)}
@heading update

@itemize
@item
:type

t

@item
:initform

(lambda nil (remhash helm-ff-default-directory helm-ff--list-directory-cache))

@item
:documentation

Function called with no parameters at before ``init'' function
when @code{helm-force-update} is called.
@end itemize

@anchor{volatile (7)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (28)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-browse-project-override-inheritor
@chapter class: helm-browse-project-override-inheritor

@image{helm-figures/helm-browse-project-override-inheritor,,,,.png}

@hcindex helm-browse-project-override-inheritor

@hcindex helm-type-file

@hcindex helm-browse-project-source

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-type-file}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-browse-project-source}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (29)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-file))
:before ((source helm-type-file))
:after ((source helm-browse-project-override-inheritor))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-browse-project-source
@chapter class: helm-browse-project-source

Class to define a source in @code{helm-browse-project} handling non
VC handled directories.

@image{helm-figures/helm-browse-project-source,,,,.png}

@hcindex helm-browse-project-source

@hcindex helm-source-in-buffer

@hcindex helm-browse-project-override-inheritor

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}

@item
@ref{class helm-browse-project-override-inheritor}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (12)}
@heading init

@itemize
@item
:type

t

@item
:initform

'helm-default-init-source-in-buffer-function

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (17)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-candidates-in-buffer

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{data (4)}
@heading data

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A string, a list or a buffer that will be used to feed the @code{helm-candidates-buffer}.
This data will be passed in a function added to the init slot and
the buffer will be build with @code{helm-init-candidates-in-buffer} or directly
with @code{helm-candidates-buffer} if data is a buffer.
This is an easy and fast method to build a @code{candidates-in-buffer} source.
@end itemize

@anchor{filter-one-by-one (1)}
@heading filter-one-by-one

@itemize
@item
:type

t

@item
:initform

(lambda (c) (if (with-helm-buffer helm-ff-transformer-show-only-basename) (cons (propertize (helm-basename c) 'face 'helm-ff-file) c) (propertize c 'face 'helm-ff-file)))

@item
:documentation

A transformer function that treat candidates one by one.
It is called with one arg the candidate.
It is faster than @code{filtered-candidate-transformer} or
@code{candidate-transformer}, but should be used only in sources
that recompute constantly their candidates, e.g @code{helm-source-find-files}.
Filtering happen early and candidates are treated
one by one instead of re-looping on the whole list.
If used with @code{filtered-candidate-transformer} or @code{candidate-transformer}
these functions should treat the candidates transformed by the
@code{filter-one-by-one} function in consequence.
@end itemize

@anchor{get-line (6)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring-no-properties

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{match (7)}
@heading match

@itemize
@item
:type

t

@item
:initform

'(identity)

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{match-part (1)}
@heading match-part

@itemize
@item
:type

t

@item
:initform

(lambda (c) (if (with-helm-buffer helm-ff-transformer-show-only-basename) (helm-basename c) c))

@item
:documentation

Allow matching only one part of candidate.
If source contain match-part attribute, match is computed only
on part of candidate returned by the call of function provided
by this attribute. The function should have one arg, candidate,
and return only a specific part of candidate.
On async sources, as matching is done by the backend, this have
no effect apart for highlighting matches.
@end itemize

@anchor{migemo (11)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{root-dir}
@heading root-dir

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation
@end itemize

@anchor{search (4)}
@heading search

@itemize
@item
:type

t

@item
:initform

'(helm-candidates-in-buffer-search-default-fn)

@item
:documentation

List of functions like @code{re-search-forward} or @code{search-forward}.
Buffer search function used by @code{helm-candidates-in-buffer}.
By default, @code{helm-candidates-in-buffer} uses @code{re-search-forward}.
The function should take one arg PATTERN@.
If your search function needs to handle negation like multimatch,
this function should returns in such case a cons cell of two integers defining
the beg and end positions to match in the line previously matched by
@code{re-search-forward} or similar, and move point to next line
(See how the @code{helm-mm-3-search-base} and @code{helm-fuzzy-search} functions are working).

NOTE: FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{search-strict (4)}
@heading search-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a search function within a source and
helm-multi-match is enabled, the result of all searching
functions will be concatened, which in some cases is not what
is wanted. When using @code{search-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using a nil value for
      :MULTIMATCH slot.
@end itemize

@anchor{volatile (8)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (30)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))
((_source helm-type-file))
:before ((source helm-type-file))
:after ((source helm-browse-project-override-inheritor))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-file-cache
@chapter class: helm-file-cache

@image{helm-figures/helm-file-cache,,,,.png}

@hcindex helm-file-cache

@hcindex helm-source-in-buffer

@hcindex helm-type-file

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}

@item
@ref{class helm-type-file}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (13)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (require 'filecache))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (18)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-candidates-in-buffer

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{data (5)}
@heading data

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

A string, a list or a buffer that will be used to feed the @code{helm-candidates-buffer}.
This data will be passed in a function added to the init slot and
the buffer will be build with @code{helm-init-candidates-in-buffer} or directly
with @code{helm-candidates-buffer} if data is a buffer.
This is an easy and fast method to build a @code{candidates-in-buffer} source.
@end itemize

@anchor{get-line (7)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring-no-properties

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{match (8)}
@heading match

@itemize
@item
:type

t

@item
:initform

'(identity)

@item
:documentation

List of functions called with one parameter: a candidate. The
function should return non-nil if the candidate matches the
current pattern (see variable @code{helm-pattern}).

When using @code{candidates-in-buffer} its default value is @code{identity} and
don't have to be changed, use the @code{search} slot instead.

This attribute allows the source to override the default
pattern matching based on @code{string-match}. It can be used, for
example, to implement a source for file names and do the
pattern matching on the basename of files, since it's more
likely one is typing part of the basename when searching for a
file, instead of some string anywhere else in its path.

If the list contains more than one function then the list of
matching candidates from the source is constructed by appending
the results after invoking the first function on all the
potential candidates, then the next function, and so on. The
matching candidates supplied by the first function appear first
in the list of results and then results from the other
functions, respectively.

This attribute has no effect for asynchronous sources (see
attribute @code{candidates}), and sources using @code{match-dynamic}
since they perform pattern matching themselves.

Note that FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{migemo (12)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{search (5)}
@heading search

@itemize
@item
:type

t

@item
:initform

'(helm-candidates-in-buffer-search-default-fn)

@item
:documentation

List of functions like @code{re-search-forward} or @code{search-forward}.
Buffer search function used by @code{helm-candidates-in-buffer}.
By default, @code{helm-candidates-in-buffer} uses @code{re-search-forward}.
The function should take one arg PATTERN@.
If your search function needs to handle negation like multimatch,
this function should returns in such case a cons cell of two integers defining
the beg and end positions to match in the line previously matched by
@code{re-search-forward} or similar, and move point to next line
(See how the @code{helm-mm-3-search-base} and @code{helm-fuzzy-search} functions are working).

NOTE: FUZZY-MATCH slot will overhide value of this slot.
@end itemize

@anchor{search-strict (5)}
@heading search-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a search function within a source and
helm-multi-match is enabled, the result of all searching
functions will be concatened, which in some cases is not what
is wanted. When using @code{search-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using a nil value for
      :MULTIMATCH slot.
@end itemize

@anchor{volatile (9)}
@heading volatile

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Indicates the source assembles the candidate list dynamically,
so it shouldn't be cached within a single Helm
invocation. It is only applicable to synchronous sources,
because asynchronous sources are not cached.
@end itemize

@anchor{Specialized Methods (31)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))
((_source helm-type-file))
:before ((source helm-type-file))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-recentf-source
@chapter class: helm-recentf-source

@image{helm-figures/helm-recentf-source,,,,.png}

@hcindex helm-recentf-source

@hcindex helm-source-sync

@hcindex helm-type-file

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}

@item
@ref{class helm-type-file}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (14)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (require 'recentf) (when helm-turn-on-recentf (recentf-mode 1)))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidates (19)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

(lambda nil recentf-list)

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{match-dynamic (6)}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-part (2)}
@heading match-part

@itemize
@item
:type

t

@item
:initform

(lambda (candidate) (if (or helm-ff-transformer-show-only-basename helm-recentf--basename-flag) (helm-basename candidate) candidate))

@item
:documentation

Allow matching only one part of candidate.
If source contain match-part attribute, match is computed only
on part of candidate returned by the call of function provided
by this attribute. The function should have one arg, candidate,
and return only a specific part of candidate.
On async sources, as matching is done by the backend, this have
no effect apart for highlighting matches.
@end itemize

@anchor{match-strict (6)}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo (13)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{pattern-transformer (1)}
@heading pattern-transformer

@itemize
@item
:type

t

@item
:initform

'helm-recentf-pattern-transformer

@item
:documentation

It's a function or a list of functions called with one argument
before computing matches. Its argument is @code{helm-pattern}.
Functions should return transformed @code{helm-pattern}.

It is useful to change interpretation of @code{helm-pattern}.
@end itemize

@anchor{persistent-action (3)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'helm-ff-kill-or-find-buffer-fname

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{Specialized Methods (32)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))
((_source helm-type-file))
:before ((source helm-type-file))
:after ((source helm-recentf-source))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-files-in-current-dir-source
@chapter class: helm-files-in-current-dir-source

@image{helm-figures/helm-files-in-current-dir-source,,,,.png}

@hcindex helm-files-in-current-dir-source

@hcindex helm-source-sync

@hcindex helm-type-file

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}

@item
@ref{class helm-type-file}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{candidates (20)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

(lambda nil (with-helm-current-buffer (let ((dir (helm-current-directory))) (when (file-accessible-directory-p dir) (directory-files dir t)))))

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{fuzzy-match (1)}
@heading fuzzy-match

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Enable fuzzy matching in this source.
This will overwrite settings in MATCH slot, and for
sources built with child class @code{helm-source-in-buffer} the SEARCH slot.
This is an easy way of enabling fuzzy matching, but you can use the MATCH
or SEARCH slots yourself if you want something more elaborated, mixing
different type of match (See @code{helm-source-buffers} class for example).

This attribute is not supported for asynchronous sources
since they perform pattern matching themselves.
@end itemize

@anchor{match-dynamic (7)}
@heading match-dynamic

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Disable all helm matching functions when non nil.
The :candidates function in this case is in charge of fetching
candidates dynamically according to @code{helm-pattern}.
Note that :volatile is automatically enabled when using this, so no
need to specify it.
@end itemize

@anchor{match-part (3)}
@heading match-part

@itemize
@item
:type

t

@item
:initform

(lambda (candidate) (if (or helm-ff-transformer-show-only-basename helm-recentf--basename-flag) (helm-basename candidate) candidate))

@item
:documentation

Allow matching only one part of candidate.
If source contain match-part attribute, match is computed only
on part of candidate returned by the call of function provided
by this attribute. The function should have one arg, candidate,
and return only a specific part of candidate.
On async sources, as matching is done by the backend, this have
no effect apart for highlighting matches.
@end itemize

@anchor{match-strict (7)}
@heading match-strict

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

When specifying a match function within a source and
helm-multi-match is enabled, the result of all matching
functions will be concatened, which in some cases is not what
is wanted. When using @code{match-strict} only this or these
functions will be used. You can specify those functions as a
list of functions or a single symbol function.

NOTE: This have the same effect as using :MULTIMATCH nil.
@end itemize

@anchor{migemo (14)}
@heading migemo

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Enable migemo.
When multimatch is disabled, you can give the symbol 'nomultimatch as value
to force not using generic migemo matching function.
In this case you have to provide your own migemo matching funtion
that kick in when @code{helm-migemo-mode} is enabled.
Otherwise it will be available for this source once @code{helm-migemo-mode}
is enabled when non-nil.
@end itemize

@anchor{pattern-transformer (2)}
@heading pattern-transformer

@itemize
@item
:type

t

@item
:initform

'helm-recentf-pattern-transformer

@item
:documentation

It's a function or a list of functions called with one argument
before computing matches. Its argument is @code{helm-pattern}.
Functions should return transformed @code{helm-pattern}.

It is useful to change interpretation of @code{helm-pattern}.
@end itemize

@anchor{Specialized Methods (33)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))
((_source helm-type-file))
:before ((source helm-type-file))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-grep-class
@chapter class: helm-grep-class

@image{helm-figures/helm-grep-class,,,,.png}

@hcindex helm-grep-class

@hcindex helm-source-async

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-async}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{action (7)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-grep-actions

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{after-init-hook (2)}
@heading after-init-hook

@itemize
@item
:type

t

@item
:initform

'helm-grep-after-init-hook

@item
:documentation

A local hook that run at end of initilization of this source.
i.e After the creation of @code{helm-buffer}.

Should be a variable.
Can be also an anonymous function or a list of functions
directly added to slot, this is not recommended though.
@end itemize

@anchor{backend}
@heading backend

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

The grep backend that will be used.
It is actually used only as an internal flag
and doesn't set the backend by itself.
You probably don't want to modify this.
@end itemize

@anchor{before-init-hook (2)}
@heading before-init-hook

@itemize
@item
:type

t

@item
:initform

'helm-grep-before-init-hook

@item
:documentation

A local hook that run at beginning of initilization of this source.
i.e Before the creation of @code{helm-buffer}.

Should be a variable (defined with defvar).
Can be also an anonymous function or a list of functions
directly added to slot, this is not recommended though.
@end itemize

@anchor{candidate-number-limit (5)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

9999

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{candidates-process (3)}
@heading candidates-process

@itemize
@item
:type

t

@item
:initform

'helm-grep-collect-candidates

@item
:documentation

This attribute is used to define a process as candidate.
The function called with no arguments must return a process
i.e. @code{processp}, it use typically @code{start-process} or @code{make-process},
see (info ``(elisp) Asynchronous Processes'').

NOTE:
When building the source at runtime you can give directly a process
as value, otherwise wrap the process call into a function.
The process buffer should be nil, otherwise, if you use
@code{helm-buffer} give to the process a sentinel.
@end itemize

@anchor{filtered-candidate-transformer (10)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

#'helm-grep-fc-transformer

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{group (3)}
@heading group

@itemize
@item
:type

t

@item
:initform

'helm-grep

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{help-message (7)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-grep-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{history (1)}
@heading history

@itemize
@item
:type

t

@item
:initform

'helm-grep-history

@item
:documentation

Allow passing history variable to helm from source.
It should be a quoted symbol.
Passing the history variable here have no effect
so add it also in the @code{helm} call with the :history keyword.
The main point of adding the variable here
is to make it available when resuming.
@end itemize

@anchor{keymap (9)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-grep-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{nohighlight (5)}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{nomark (3)}
@heading nomark

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Don't allow marking candidates when this attribute is present.
@end itemize

@anchor{pcre}
@heading pcre

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Backend is using pcre regexp engine when non-nil.
@end itemize

@anchor{persistent-action (4)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'helm-grep-persistent-action

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{persistent-help (3)}
@heading persistent-help

@itemize
@item
:type

t

@item
:initform

``Jump to line (@code{C-u} Record in mark ring)''

@item
:documentation

A string to explain persistent-action of this source. It also
accepts a function or a variable name.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
@end itemize

@anchor{requires-pattern (3)}
@heading requires-pattern

@itemize
@item
:type

t

@item
:initform

2

@item
:documentation

If present matches from the source are shown only if the
pattern is not empty. Optionally, it can have an integer
parameter specifying the required length of input which is
useful in case of sources with lots of candidates.
@end itemize

@anchor{Specialized Methods (34)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-async))
((source helm-grep-class))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-grep-ag-class
@chapter class: helm-grep-ag-class

@image{helm-figures/helm-grep-ag-class,,,,.png}

@hcindex helm-grep-ag-class

@hcindex helm-source-async

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-async}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{action (8)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-grep-actions

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{candidate-number-limit (6)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

99999

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{filtered-candidate-transformer (11)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

#'helm-grep-fc-transformer

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{group (4)}
@heading group

@itemize
@item
:type

t

@item
:initform

'helm-grep

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{help-message (8)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-grep-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{history (2)}
@heading history

@itemize
@item
:type

t

@item
:initform

'helm-grep-ag-history

@item
:documentation

Allow passing history variable to helm from source.
It should be a quoted symbol.
Passing the history variable here have no effect
so add it also in the @code{helm} call with the :history keyword.
The main point of adding the variable here
is to make it available when resuming.
@end itemize

@anchor{keymap (10)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-grep-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{nohighlight (6)}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{nomark (4)}
@heading nomark

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Don't allow marking candidates when this attribute is present.
@end itemize

@anchor{pcre (1)}
@heading pcre

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Backend is using pcre regexp engine when non--nil.
@end itemize

@anchor{persistent-action (5)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'helm-grep-persistent-action

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{persistent-help (4)}
@heading persistent-help

@itemize
@item
:type

t

@item
:initform

``Jump to line (@code{C-u} Record in mark ring)''

@item
:documentation

A string to explain persistent-action of this source. It also
accepts a function or a variable name.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
@end itemize

@anchor{requires-pattern (4)}
@heading requires-pattern

@itemize
@item
:type

t

@item
:initform

2

@item
:documentation

If present matches from the source are shown only if the
pattern is not empty. Optionally, it can have an integer
parameter specifying the required length of input which is
useful in case of sources with lots of candidates.
@end itemize

@anchor{Specialized Methods (35)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-async))
((source helm-grep-ag-class))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-gid-source
@chapter class: helm-gid-source

@image{helm-figures/helm-gid-source,,,,.png}

@hcindex helm-gid-source

@hcindex helm-source-async

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-async}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{action (9)}
@heading action

@itemize
@item
:type

t

@item
:initform

(helm-make-actions ``Find File'' 'helm-grep-action ``Find file other frame'' 'helm-grep-other-frame ``Save results in grep buffer'' 'helm-grep-save-results ``Find file other window'' 'helm-grep-other-window)

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{candidate-number-limit (7)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

99999

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{candidates-process (4)}
@heading candidates-process

@itemize
@item
:type

t

@item
:initform

#'helm-gid-candidates-process

@item
:documentation

This attribute is used to define a process as candidate.
The function called with no arguments must return a process
i.e. @code{processp}, it use typically @code{start-process} or @code{make-process},
see (info ``(elisp) Asynchronous Processes'').

NOTE:
When building the source at runtime you can give directly a process
as value, otherwise wrap the process call into a function.
The process buffer should be nil, otherwise, if you use
@code{helm-buffer} give to the process a sentinel.
@end itemize

@anchor{db-dir}
@heading db-dir

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Location of ID file.
@end itemize

@anchor{filtered-candidate-transformer (12)}
@heading filtered-candidate-transformer

@itemize
@item
:type

t

@item
:initform

#'helm-gid-filtered-candidate-transformer

@item
:documentation

It has the same format as @code{candidate-transformer}, except the
function is called with two parameters: the candidate list and
the source.

This transformer is run on the candidate list which is already
filtered by the current pattern. While @code{candidate-transformer}
is run only once, it is run every time the input pattern is
changed.

It can be used to transform the candidate list dynamically, for
example, based on the current pattern.

In some cases it may also be more efficent to perform candidate
transformation here, instead of with @code{candidate-transformer}
even if this transformation is done every time the pattern is
changed.  For example, if a candidate set is very large then
@code{candidate-transformer} transforms every candidate while only
some of them will actually be displayed due to the limit
imposed by @code{helm-candidate-number-limit}.

Note that @code{candidates} and @code{candidate-transformer} is run
already, so the given transformer function should also be able
to handle candidates with (DISPLAY . REAL) format.
@end itemize

@anchor{header-name (2)}
@heading header-name

@itemize
@item
:type

t

@item
:initform

(lambda (name) (concat name `` ['' (helm-get-attr 'db-dir) ``]''))

@item
:documentation

A function returning the display string of the header.
Its argument is the name of the source. This attribute is useful to
add an additional information with the source name.
It doesn't modify the name of the source.
@end itemize

@anchor{help-message (9)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-grep-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{history (3)}
@heading history

@itemize
@item
:type

t

@item
:initform

'helm-grep-history

@item
:documentation

Allow passing history variable to helm from source.
It should be a quoted symbol.
Passing the history variable here have no effect
so add it also in the @code{helm} call with the :history keyword.
The main point of adding the variable here
is to make it available when resuming.
@end itemize

@anchor{nohighlight (7)}
@heading nohighlight

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Disable highlighting matches in this source.
This will disable generic highlighting of matches,
but some specialized highlighting can be done from elsewhere,
i.e from @code{filtered-candidate-transformer} or @code{filter-one-by-one} slots.
So use this to either disable completely highlighting in your source,
or to disable highlighting and use a specialized highlighting matches
function for this source.
Remember that this function should run AFTER all filter functions if those
filter functions are modifying face properties, though it is possible to
avoid this by using new @code{add-face-text-property} in your filter functions.
@end itemize

@anchor{persistent-action (6)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'helm-grep-persistent-action

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{requires-pattern (5)}
@heading requires-pattern

@itemize
@item
:type

t

@item
:initform

2

@item
:documentation

If present matches from the source are shown only if the
pattern is not empty. Optionally, it can have an integer
parameter specifying the required length of input which is
useful in case of sources with lots of candidates.
@end itemize

@anchor{Specialized Methods (36)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-async))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-imenu-source
@chapter class: helm-imenu-source

@image{helm-figures/helm-imenu-source,,,,.png}

@hcindex helm-imenu-source

@hcindex helm-source-sync

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-sync}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{action (10)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-imenu-action

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{candidate-transformer (3)}
@heading candidate-transformer

@itemize
@item
:type

t

@item
:initform

'helm-imenu-transformer

@item
:documentation

It's a function or a list of functions called with one argument
when the completion list from the source is built. The argument
is the list of candidates retrieved from the source. The
function should return a transformed list of candidates which
will be used for the actual completion.  If it is a list of
functions, it calls each function sequentially.

This can be used to transform or remove items from the list of
candidates.

Note that @code{candidates} is run already, so the given transformer
function should also be able to handle candidates with (DISPLAY
. REAL) format.
@end itemize

@anchor{candidates (21)}
@heading candidates

@itemize
@item
:type

t

@item
:initform

'helm-imenu-candidates

@item
:documentation

Specifies how to retrieve candidates from the source.
It can either be a variable name, a function called with no parameters
or the actual list of candidates.

Do NOT use this for asynchronous sources, use @code{candidates-process}
instead.

The list must be a list whose members are strings, symbols
or (DISPLAY . REAL) pairs.

In case of (DISPLAY . REAL) pairs, the DISPLAY string is shown
in the Helm buffer, but the REAL one is used as action
argument when the candidate is selected. This allows a more
readable presentation for candidates which would otherwise be,
for example, too long or have a common part shared with other
candidates which can be safely replaced with an abbreviated
string for display purposes.

Note that if the (DISPLAY . REAL) form is used then pattern
matching is done on the displayed string, not on the real
value.

This function, generally should not compute candidates according to
@code{helm-pattern} which defeat all the Helm's matching mechanism
i.e. multiple pattern matching and/or fuzzy matching.
If you want to do so, use :match-dynamic slot to be sure matching
occur only in :candidates function and there is no conflict with
other match functions.
@end itemize

@anchor{group (5)}
@heading group

@itemize
@item
:type

t

@item
:initform

'helm-imenu

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{help-message (10)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-imenu-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (11)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

helm-imenu-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{nomark (5)}
@heading nomark

@itemize
@item
:type

t

@item
:initform

t

@item
:documentation

Don't allow marking candidates when this attribute is present.
@end itemize

@anchor{persistent-action (7)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'helm-imenu-persistent-action

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{persistent-help (5)}
@heading persistent-help

@itemize
@item
:type

t

@item
:initform

``Show this entry''

@item
:documentation

A string to explain persistent-action of this source. It also
accepts a function or a variable name.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
@end itemize

@anchor{Specialized Methods (37)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-sync))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-info-source
@chapter class: helm-info-source

@image{helm-figures/helm-info-source,,,,.png}

@hcindex helm-info-source

@hcindex helm-source-in-buffer

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (15)}
@heading init

@itemize
@item
:type

t

@item
:initform

#'helm-info-init

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{action (11)}
@heading action

@itemize
@item
:type

t

@item
:initform

'((``Goto node'' . helm-info-goto))

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{display-to-real (1)}
@heading display-to-real

@itemize
@item
:type

t

@item
:initform

#'helm-info-display-to-real

@item
:documentation

Transform the selected candidate when passing it to action.

Function called with one parameter, the selected candidate.

Avoid recomputing all candidates with candidate-transformer
or filtered-candidate-transformer to give a new value to REAL,
instead the selected candidate is transformed only when passing it
to action. This works (and make sense) only with plain string
candidates, it will NOT work when candidate is a cons cell, in this
case the real value of candidate will be used.
Example:

(helm :sources (helm-build-sync-source ``test''
             :candidates '(a b c d e)
             :display-to-real (lambda (c) (concat c ``:modified by d-t-r'')))
  :buffer ``@strong{helm test}'')

Note that this is NOT a transformer,
so the display will not be modified by this function.
@end itemize

@anchor{get-line (8)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

#'buffer-substring

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{info-file}
@heading info-file

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation
@end itemize

@anchor{Specialized Methods (38)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-locate-override-inheritor
@chapter class: helm-locate-override-inheritor

@image{helm-figures/helm-locate-override-inheritor,,,,.png}

@hcindex helm-locate-override-inheritor

@hcindex helm-type-file

@hcindex helm-locate-source

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-type-file}
@end itemize

@item @strong{children}
@itemize
@item
@ref{class helm-locate-source}
@end itemize
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{Specialized Methods (39)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((_source helm-type-file))
:before ((source helm-type-file))
:after ((source helm-locate-override-inheritor))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-locate-source
@chapter class: helm-locate-source

@image{helm-figures/helm-locate-source,,,,.png}

@hcindex helm-locate-source

@hcindex helm-source-async

@hcindex helm-locate-override-inheritor

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-async}

@item
@ref{class helm-locate-override-inheritor}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (16)}
@heading init

@itemize
@item
:type

t

@item
:initform

'helm-locate-initial-setup

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{candidate-number-limit (8)}
@heading candidate-number-limit

@itemize
@item
:type

t

@item
:initform

9999

@item
:documentation

Override @code{helm-candidate-number-limit} only for this source.
@end itemize

@anchor{candidates-process (5)}
@heading candidates-process

@itemize
@item
:type

t

@item
:initform

'helm-locate-init

@item
:documentation

This attribute is used to define a process as candidate.
The function called with no arguments must return a process
i.e. @code{processp}, it use typically @code{start-process} or @code{make-process},
see (info ``(elisp) Asynchronous Processes'').

NOTE:
When building the source at runtime you can give directly a process
as value, otherwise wrap the process call into a function.
The process buffer should be nil, otherwise, if you use
@code{helm-buffer} give to the process a sentinel.
@end itemize

@anchor{group (6)}
@heading group

@itemize
@item
:type

t

@item
:initform

'helm-locate

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{history (4)}
@heading history

@itemize
@item
:type

t

@item
:initform

'helm-file-name-history

@item
:documentation

Allow passing history variable to helm from source.
It should be a quoted symbol.
Passing the history variable here have no effect
so add it also in the @code{helm} call with the :history keyword.
The main point of adding the variable here
is to make it available when resuming.
@end itemize

@anchor{multimatch (5)}
@heading multimatch

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation

Use the multi-match algorithm when non-nil.
I.e Allow specifying multiple patterns separated by spaces.
When a pattern is prefixed by ``!'' the negation of this pattern is used,
i.e match anything but this pattern.
It is the standard way of matching in helm and is enabled by default.
It can be used with fuzzy-matching enabled, but as soon helm detect a space,
each pattern will match by regexp and will not be fuzzy.
@end itemize

@anchor{persistent-action (8)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

'helm-ff-kill-or-find-buffer-fname

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{redisplay (1)}
@heading redisplay

@itemize
@item
:type

t

@item
:initform

(progn helm-locate-fuzzy-sort-fn)

@item
:documentation

A function or a list of functions to apply to current list
of candidates when redisplaying buffer with @code{helm-redisplay-buffer}.
This is only interesting for modifying and redisplaying the whole list
of candidates in async sources.
It uses @code{identity} by default for when async sources are mixed with
normal sources, in this case these normal sources are not modified and
redisplayed as they are.
@end itemize

@anchor{requires-pattern (6)}
@heading requires-pattern

@itemize
@item
:type

t

@item
:initform

3

@item
:documentation

If present matches from the source are shown only if the
pattern is not empty. Optionally, it can have an integer
parameter specifying the required length of input which is
useful in case of sources with lots of candidates.
@end itemize

@anchor{Specialized Methods (40)}
@heading Specialized Methods:

@code{helm-source-get-action-from-type}:

((object helm-type-file))

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-async))
((_source helm-type-file))
:before ((source helm-type-file))
:after ((source helm-locate-override-inheritor))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-locate-subdirs-source
@chapter class: helm-locate-subdirs-source

@image{helm-figures/helm-locate-subdirs-source,,,,.png}

@hcindex helm-locate-subdirs-source

@hcindex helm-source-in-buffer

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{basedir}
@heading basedir

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation
@end itemize

@anchor{data (6)}
@heading data

@itemize
@item
:type

t

@item
:initform

#'helm-locate-init-subdirs

@item
:documentation

A string, a list or a buffer that will be used to feed the @code{helm-candidates-buffer}.
This data will be passed in a function added to the init slot and
the buffer will be build with @code{helm-init-candidates-in-buffer} or directly
with @code{helm-candidates-buffer} if data is a buffer.
This is an easy and fast method to build a @code{candidates-in-buffer} source.
@end itemize

@anchor{group (7)}
@heading group

@itemize
@item
:type

t

@item
:initform

'helm-locate

@item
:documentation

The current source group, default to @code{helm} when not specified.
@end itemize

@anchor{subdir}
@heading subdir

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation
@end itemize

@anchor{Specialized Methods (41)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-moccur-class
@chapter class: helm-moccur-class

@image{helm-figures/helm-moccur-class,,,,.png}

@hcindex helm-moccur-class

@hcindex helm-source-in-buffer

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{buffer-name}
@heading buffer-name

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation
@end itemize

@anchor{moccur-buffers}
@heading moccur-buffers

@itemize
@item
:type

t

@item
:initform

nil

@item
:documentation
@end itemize

@anchor{Specialized Methods (42)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node class helm-semantic-source
@chapter class: helm-semantic-source

@image{helm-figures/helm-semantic-source,,,,.png}

@hcindex helm-semantic-source

@hcindex helm-source-in-buffer

@table @asis
@item @strong{parents}
@itemize
@item
@ref{class helm-source-in-buffer}
@end itemize

@item @strong{children}
@end table

The following are some interesting slots of this class. Note that not all slots are shown here.

@anchor{init (17)}
@heading init

@itemize
@item
:type

t

@item
:initform

(lambda nil (helm-semantic--maybe-set-needs-update) (setq helm-semantic--tags-cache (semantic-fetch-tags)) (with-current-buffer (helm-candidate-buffer 'global) (let ((major-mode (with-helm-current-buffer major-mode))) (helm-semantic--fetch-candidates helm-semantic--tags-cache 0))))

@item
:documentation

Function called with no parameters when helm is started.
It is useful for collecting current state information which can be
used to create the list of candidates later.
Initialization of @code{candidates-in-buffer} is done here
with @code{helm-init-candidates-in-buffer}.
@end itemize

@anchor{action (12)}
@heading action

@itemize
@item
:type

t

@item
:initform

'helm-semantic-default-action

@item
:documentation

An alist of (DISPLAY . FUNCTION) pairs, a variable name  or a function.
FUNCTION is called with one parameter: the selected candidate.

An action other than the default can be chosen from this list
of actions for the currently selected candidate (by default
with TAB). The DISPLAY string is shown in the completions
buffer and the FUNCTION is invoked when an action is
selected. The first action of the list is the default.

You should use @code{helm-make-actions} to build this alist easily.
@end itemize

@anchor{get-line (9)}
@heading get-line

@itemize
@item
:type

t

@item
:initform

'buffer-substring

@item
:documentation

A function like @code{buffer-substring-no-properties} or @code{buffer-substring}.
This function converts region from point at line-beginning and point
at line-end in the @code{helm-candidate-buffer} to a string which will be displayed
in the @code{helm-buffer}, it takes two args BEG and END@.
By default, @code{helm-candidates-in-buffer} uses
@code{buffer-substring-no-properties} which does no conversion and doesn't carry
text properties.
@end itemize

@anchor{help-message (11)}
@heading help-message

@itemize
@item
:type

t

@item
:initform

'helm-semantic-help-message

@item
:documentation

Help message for this source.
If not present, @code{helm-help-message} value will be used.
@end itemize

@anchor{keymap (12)}
@heading keymap

@itemize
@item
:type

t

@item
:initform

'helm-semantic-map

@item
:documentation

Specific keymap for this source.
default value is @code{helm-map}.
@end itemize

@anchor{persistent-action (9)}
@heading persistent-action

@itemize
@item
:type

t

@item
:initform

(lambda (elm) (helm-semantic-default-action elm t) (helm-highlight-current-line))

@item
:documentation

Can be a either a Function called with one parameter (the
selected candidate) or a cons cell where first element is this
same function and second element a symbol (e.g never-split)
that inform @code{helm-execute-persistent-action} to not split his
window to execute this persistent action.
Example:

(defun foo-persistent-action (candidate)
   (do-something candidate))

  :persistent-action '(foo-persistent-action . never-split) ; Don't split
or
  :persistent-action 'foo-persistent-action ; Split

When specifying :persistent-action by slot directly, foo-persistent-action
will be executed without quitting helm when hitting @code{C-j}.

Note that other persistent actions can be defined using other
bindings than @code{C-j} by simply defining an interactive function bound
to a key in the keymap source.
The function should create a new attribute in source before calling
@code{helm-execute-persistent-action} on this attribute.
Example:

(defun helm-ff-persistent-delete ()
  ``Delete current candidate without quitting.''
  (interactive)
  (with-helm-alive-p
    (helm-set-attr 'quick-delete '(helm-ff-quick-delete . never-split))
    (helm-execute-persistent-action 'quick-delete)))

This function is then bound in @code{helm-find-files-map}.
@end itemize

@anchor{persistent-help (6)}
@heading persistent-help

@itemize
@item
:type

t

@item
:initform

``Show this entry''

@item
:documentation

A string to explain persistent-action of this source. It also
accepts a function or a variable name.
It will be displayed in @code{header-line} or in @code{minibuffer} depending
of value of @code{helm-echo-input-in-header-line} and @code{helm-display-header-line}.
@end itemize

@anchor{Specialized Methods (43)}
@heading Specialized Methods:

@code{helm--setup-source}:

((_source helm-source))
:before ((source helm-source))
((source helm-source-in-buffer))

@code{helm-setup-user-source}:

((_source helm-source))

@node Main Index
@chapter Main Index

@printindex cp

@node Key Index
@chapter Key Index

@printindex ky

@node Command and Function Index
@chapter Command and Function Index

@printindex fn

@node Variable Index
@chapter Variable Index

This is not a complete index of variables and faces, only the ones
that are mentioned in the manual.  For a more complete list, use
@kbd{M-x org-customize} and then click yourself through the tree.

@printindex vr

@node Class Index
@chapter Class Index

@printindex hc

@bye